// SPDX-License-Identifier: LGPL-2.1
// Copyright 2021 Daniel Vogelbacher <daniel@chaospixel.com>

use crate::imgop::{
  raw::{apply_whitebalance, rescale},
  sensor::bayer::BayerPattern,
  Dim2,
};
use rayon::prelude::*;

/// Debayer image by using superpixel method.
/// Each output pixel RGB tuple is generated by 4 pixels from input.
/// The result image is 1/4 of size.
///
/// Before debayer, WB coefficents are applied. If you don't won't WB correction,
/// just supply 1.0 as factor.
pub fn debayer_superpixel(
  pixels: &[u16],
  pattern: BayerPattern,
  dim: Dim2,
  black_level: &[f32; 4],
  white_level: &[f32; 4],
  wb_coeff: &[f32; 4],
) -> (Vec<[f32; 3]>, usize, usize) {
  let rgb = pixels
    .par_chunks_exact(dim.w * 2)
    .map(|s| {
      let (r1, r2) = s.split_at(dim.w);
      r1.chunks_exact(2)
        .zip(r2.chunks_exact(2))
        .map(|(a, b)| {
          let scaled = rescale(&[a[0], a[1], b[0], b[1]], black_level, white_level);
          let p = apply_whitebalance(&scaled, wb_coeff);
          match pattern {
            BayerPattern::RGGB => [p[0], (p[1] + p[2]) / 2.0, p[3]],
            BayerPattern::BGGR => [p[3], (p[1] + p[2]) / 2.0, p[0]],
            BayerPattern::GBRG => [p[2], (p[0] + p[3]) / 2.0, p[1]],
            BayerPattern::GRBG => [p[1], (p[0] + p[3]) / 2.0, p[2]],
          }
        })
        .collect::<Vec<_>>()
    })
    .flatten()
    .collect();
  (rgb, dim.w >> 1, dim.h >> 1)
}
